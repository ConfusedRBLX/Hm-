<!DOCTYPE html>
<html>
<head>
    <title>3d audio live stream</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
</head>
<body>
<input type="range" step="0.25" min="0.25" max="4" value="1" oninput="setBuffer(this.value); this.nextElementSibling.innerText = this.value;"/> Set buffer (<span>1</span> sec)
<br/>
<input type="checkbox" onclick="set3D(this.checked);" checked/> Toggle 3D
<br/>
<button onclick="doit(this);">connect</button>
<script>
    let context = new AudioContext(),
        panner = context.createPanner(),
        doneit = false,
        far = true,
        threeDee = true,
        lastDur = -1,
        bufferSize = 4;

    const cmn = context.createChannelMerger(1),
          queue = [];

    function play(ch) {
        const source = context.createBufferSource();

        source.buffer = ch;
        source.connect(threeDee ? cmn : context.destination);
        if (lastDur == -1) lastDur = ch.duration;
        source.start(context.currentTime + 0.1 + (lastDur - (bufferSize / 4)));

        lastDur = ch.duration;
    }

    panner.maxDistance = 16.1;
    panner.rolloffFactor = 1;
    panner.distanceModel = "linear";
    panner.panningModel = "HRTF";
    panner.coneInnerAngle = 30;
    panner.coneOuterAngle = 45;
    panner.coneOuterGain = 0;
    panner.orientationX.value = 0;
    panner.orientationY.value = 0;
    panner.orientationZ.value = 0;
    panner.positionX.value = 0;
    panner.positionY.value = 0;
    panner.positionZ.value = 0;
    cmn.connect(panner);
    panner.connect(context.destination);

    function getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    function set3D(val) {
        threeDee = val;
    }

    function setBuffer(val) {
        bufferSize = val * 4;
    }

    function doit(elem) {
        if (doneit) return;
        const uname = prompt("Please enter your username in-game:", getCookie("uname"));
        if (!uname) return;
        if (!uname.match(/^[a-zA-Z0-9_]{2,16}$/)) return;
        doneit = true;
        document.cookie = "uname=" + uname;
        elem.outerHTML = "";
        const socket = new WebSocket("ws" + window.location.href.slice(4));
        socket.binaryType = 'arraybuffer';
        socket.onopen = () => {
            socket.send(uname);
        };
        socket.onclose = () => {
            window.location.reload();
        };
        socket.onmessage = e => {
            if (typeof e.data == "string") {
                if (e.data == "alive") {
                    setTimeout(() => socket.send("keep"), 5000);
                } else if (e.data == "key") {
                    const key = prompt("Please enter the code received in-game to connect!");
                    if (!key) {
                        socket.close();
                        return;
                    }
                    if (!key.match(/^[a-zA-Z0-9]{10}$/)) {
                        socket.close();
                        return;
                    }
                    socket.send(key);
                    return;
                }
                const pos = e.data.split(",");
                if (isNaN(+pos[0])) {
                    far = true;
                } else {
                    far = false;
                    panner.positionX.value = +pos[0];
                    panner.positionY.value = +pos[1];
                    panner.positionZ.value = +pos[2];
                }
            } else {
                if (!far) {
                    queue.push(e.data);
                    if (queue.length >= bufferSize) {
                        context.decodeAudioData(concatArrayBuffers.apply(null, queue), bf => {
                            play(bf);
                        }, err => console.error(err));
                        queue.length = 0;
                    }
                }
            }
        };
    }

    // https://gist.github.com/gogromat/446e962bde1122747cfe
    /**
	 * Concatenates n-many ArrayBuffers
	 * Based on the https://gist.github.com/72lions/4528834
	 *
	 * @param {...ArrayBuffer} ArrayBuffer(s) to concatenate
	 * @return {ArrayBuffer} The new ArrayBuffer created out of n buffers.
	 */
	var concatArrayBuffers = function () {
	    var buffers = Array.prototype.slice.call(arguments),
	        buffersLengths = buffers.map(function(b) { return b.byteLength; }),
	        totalBufferlength = buffersLengths.reduce(function(p, c) { return p+c; }, 0),
	        unit8Arr = new Uint8Array(totalBufferlength);
	    buffersLengths.reduce(function (p, c, i) {
	        unit8Arr.set(new Uint8Array(buffers[i]), p);
	        return p+c;
	    }, 0);
	    return unit8Arr.buffer;
    };
</script>
</body>
</html>
