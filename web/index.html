<!DOCTYPE html>
<html>
<head>
    <title>3d audio live stream</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
</head>
<body>
<button onclick="window.doit(this);">connect</button>
<script type="text/javascript" src="jsmad.wrapper.js"></script>
<script>
    window.doit = function() {
        alert("Still loading, please wait!");
    };

    function makeAudioBuffer(pcmArrayBuffer) {
        const interleavedPcmData = new DataView(pcmArrayBuffer);
        const audioBuffer = new AudioBuffer({
            length: pcmArrayBuffer.byteLength / 2 / 2,
            numberOfChannels: 2,
            sampleRate: 44100
        });
        const planarChannelDatas = [];
        planarChannelDatas.push(audioBuffer.getChannelData(0));
        planarChannelDatas.push(audioBuffer.getChannelData(1));
        for (let i = 0; i < interleavedPcmData.byteLength; i += 2) {
            const channelNumber = i / 2 % 2;
            const value = interleavedPcmData.getInt16(i, true);
            planarChannelDatas[channelNumber][Math.floor(i / 2 / 2)] = value < 0 ? value / 32768 : value / 32767;
        }
        audioBuffer.copyToChannel(planarChannelDatas[0], 0, 0);
        audioBuffer.copyToChannel(planarChannelDatas[1], 1, 0);
        return audioBuffer;
    }

    let context = new AudioContext(),
        panner = context.createPanner(),
        decoder = new Module.Decoder(),
        doneit = false,
        far = true;

    const cmn = context.createChannelMerger(1);

    function play(ch) {
        const source = context.createBufferSource();

        source.buffer = ch;
        source.connect(cmn);

        source.start();
    }

    panner.maxDistance = 16.1;
    panner.rolloffFactor = 1;
    panner.distanceModel = "linear";
    panner.panningModel = "HRTF";
    panner.coneInnerAngle = 30;
    panner.coneOuterAngle = 45;
    panner.coneOuterGain = 0;
    panner.orientationX.value = 0;
    panner.orientationY.value = 0;
    panner.orientationZ.value = 0;
    panner.positionX.value = 0;
    panner.positionY.value = 0;
    panner.positionZ.value = 0;
    cmn.connect(panner);
    panner.connect(context.destination);

    function getCookie(cname) {
        let name = cname + "=";
        let decodedCookie = decodeURIComponent(document.cookie);
        let ca = decodedCookie.split(';');
        for (let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    window.doit = function(elem) {
        if (doneit) return;
        const uname = prompt("Please enter your username in-game:", getCookie("uname"));
        if (!uname) return;
        if (!uname.match(/^[a-zA-Z0-9_]{2,16}$/)) return;
        doneit = true;
        document.cookie = "uname=" + uname;
        elem.outerHTML = "";
        const hrf = window.location.href;
        const socket = new WebSocket("ws" + hrf.slice(4, hrf.endsWith("/") ? -1 : hrf.length) + "/audio");
        socket.binaryType = 'arraybuffer';
        socket.onopen = () => {
            socket.send(uname);
            const key = prompt("Please enter the code received in-game to connect!");
            if (!key) {
                socket.close();
                return;
            }
            if (!key.match(/^[a-zA-Z0-9]{10}$/)) {
                socket.close();
                return;
            }
            socket.send(key);
        };
        socket.onmessage = e => {
            if (typeof e.data == "string") {
                const pos = e.data.split(",");
                if (isNaN(+pos[0])) {
                    far = true;
                } else {
                    far = false;
                    panner.positionX.value = +pos[0];
                    panner.positionY.value = +pos[1];
                    panner.positionZ.value = +pos[2];
                }
            } else {
                if (!far) {
                    var src = new Uint8Array(e.data);

                    var ps = src.length;
                    var ptr = Module._malloc(ps);

                    var arr = new Uint8Array(Module.HEAPU8.buffer, ptr, ps);
                    var portion = new Uint8Array(e.data, 0, ps);
                    arr.set(portion, 0);

                    decoder.addFragment(ptr, ps);

                    Module._malloc(256);
                }
            }
        };

        setInterval(() => {
            if (decoder.hasMore()) {
                var audio = decoder.decode(20);
                if (audio) {
                    console.log(audio);
                    play(audio);
                }
            }
        }, 0);
    }
</script>
</body>
</html>
