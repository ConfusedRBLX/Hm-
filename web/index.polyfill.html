<!DOCTYPE html>
<html>
<head>
    <title>3d audio live stream</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
</head>
<body>
<button onclick="window.doit(this);">connect</button>
<script type="text/javascript" src="libav-3.6.4.4.1-fat.js"></script>
<script type="text/javascript" src="libavjs-webcodecs-polyfill.min.js"></script>
<script>
    window.doit = function() {
        alert("Still loading, please wait!");
    };
    (async function() {
        if (!window.AudioDecoder || !window.EncodedAudioChunk) {
            await LibAVWebCodecs.load();
            window.AudioDecoder = window.AudioDecoder || LibAVWebCodecs.AudioDecoder;
            window.EncodedAudioChunk = window.EncodedAudioChunk || LibAVWebCodecs.EncodedVideoChunk;
        }

        function makeAudioBuffer(pcmArrayBuffer) {
            const interleavedPcmData = new DataView(pcmArrayBuffer);
            const audioBuffer = new AudioBuffer({
                length: pcmArrayBuffer.byteLength / 2 / 2,
                numberOfChannels: 2,
                sampleRate: 44100
            });
            const planarChannelDatas = [];
            planarChannelDatas.push(audioBuffer.getChannelData(0));
            planarChannelDatas.push(audioBuffer.getChannelData(1));
            for (let i = 0; i < interleavedPcmData.byteLength; i += 2) {
                const channelNumber = i / 2 % 2;
                const value = interleavedPcmData.getInt16(i, true);
                planarChannelDatas[channelNumber][Math.floor(i / 2 / 2)] = value < 0 ? value / 32768 : value / 32767;
            }
            audioBuffer.copyToChannel(planarChannelDatas[0], 0, 0);
            audioBuffer.copyToChannel(planarChannelDatas[1], 1, 0);
            return audioBuffer;
        }

        let context = new AudioContext(),
            panner = context.createPanner(),
            decoder = new AudioDecoder({
                output: audioData => {
                    const copyOpts = {planeIndex: 0, format: "s16"};
                    const ab = new ArrayBuffer(audioData.allocationSize(copyOpts));
                    audioData.copyTo(ab, copyOpts);
                    play(makeAudioBuffer(ab));
                },
                error: e => console.error(e)
            }),
            doneit = false,
            far = true;

        decoder.configure({
            codec: "vorbis",
            sampleRate: 44100,
            numberOfChannels: 2
        });

        const cmn = context.createChannelMerger(1);

        function play(ch) {
            const source = context.createBufferSource();

            source.buffer = ch;
            source.connect(cmn);

            source.start();
        }

        panner.maxDistance = 16.1;
        panner.rolloffFactor = 1;
        panner.distanceModel = "linear";
        panner.panningModel = "HRTF";
        panner.coneInnerAngle = 30;
        panner.coneOuterAngle = 45;
        panner.coneOuterGain = 0;
        panner.orientationX.value = 0;
        panner.orientationY.value = 0;
        panner.orientationZ.value = 0;
        panner.positionX.value = 0;
        panner.positionY.value = 0;
        panner.positionZ.value = 0;
        cmn.connect(panner);
        panner.connect(context.destination);

        function getCookie(cname) {
            let name = cname + "=";
            let decodedCookie = decodeURIComponent(document.cookie);
            let ca = decodedCookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }

        window.doit = function(elem) {
            if (doneit) return;
            const uname = prompt("Please enter your username in-game:", getCookie("uname"));
            if (!uname) return;
            if (!uname.match(/^[a-zA-Z0-9_]{2,16}$/)) return;
            doneit = true;
            document.cookie = "uname=" + uname;
            elem.outerHTML = "";
            const hrf = window.location.href;
            const socket = new WebSocket("ws" + hrf.slice(4, hrf.endsWith("/") ? -1 : hrf.length) + "/audio");
            socket.binaryType = 'arraybuffer';
            socket.onopen = () => {
                socket.send(uname);
                const key = prompt("Please enter the code received in-game to connect!");
                if (!key) {
                    socket.close();
                    return;
                }
                if (!key.match(/^[a-zA-Z0-9]{10}$/)) {
                    socket.close();
                    return;
                }
                socket.send(key);
            };
            socket.onmessage = e => {
                if (typeof e.data == "string") {
                    const pos = e.data.split(",");
                    if (isNaN(+pos[0])) {
                        far = true;
                    } else {
                        far = false;
                        panner.positionX.value = +pos[0];
                        panner.positionY.value = +pos[1];
                        panner.positionZ.value = +pos[2];
                    }
                } else {
                    if (!far) {
                        decoder.decode(new EncodedAudioChunk({type: 'key', data: e.data, timestamp: 0, duration: 0}));
                    }
                }
            };
        }
    })();
</script>
</body>
</html>
